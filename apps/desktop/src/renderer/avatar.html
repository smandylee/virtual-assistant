<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha - í”Œë¡œíŒ… ì•„ë°”íƒ€</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            user-select: none;
        }

        /* ë©”ì¸ ì»¨í…Œì´ë„ˆ */
        .floating-avatar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
            pointer-events: none;
        }

        /* ë§í’ì„  */
        .speech-bubble {
            max-width: 350px;
            min-width: 200px;
            max-height: 300px;  /* ìµœëŒ€ ë†’ì´ ì œí•œ */
            overflow-y: auto;   /* ìŠ¤í¬ë¡¤ ê°€ëŠ¥ */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 20px;
            border-radius: 20px 20px 4px 20px;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.4);
            font-size: 14px;
            line-height: 1.6;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: auto;
            word-break: keep-all;
        }

        /* ë§í’ì„  ìŠ¤í¬ë¡¤ë°” ìŠ¤íƒ€ì¼ */
        .speech-bubble::-webkit-scrollbar {
            width: 6px;
        }
        .speech-bubble::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        .speech-bubble::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.4);
            border-radius: 3px;
        }

        .speech-bubble.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .speech-bubble .message-text {
            margin-bottom: 8px;
        }

        .speech-bubble .message-time {
            font-size: 11px;
            opacity: 0.7;
            text-align: right;
        }

        /* ì…ë ¥ ì˜ì—­ */
        .input-area {
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 8px 12px;
            border-radius: 28px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            pointer-events: auto;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .input-area.show {
            opacity: 1;
            transform: translateY(0);
        }

        .input-area input {
            flex: 1;
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            color: #333;
            min-width: 180px;
            padding: 8px 4px;
        }

        .input-area input::placeholder {
            color: #999;
        }

        .input-area button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .send-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .mic-btn {
            background: #f0f0f0;
            color: #666;
        }

        .mic-btn:hover {
            background: #e0e0e0;
        }

        .mic-btn.recording {
            background: #ff4757;
            color: white;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* ì•„ë°”íƒ€ */
        .avatar-wrapper {
            position: relative;
            pointer-events: auto;
            cursor: grab;
        }

        .avatar-wrapper:active {
            cursor: grabbing;
        }

        .avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            overflow: hidden;
            border: 3px solid white;
        }

        .avatar:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 40px rgba(102, 126, 234, 0.5);
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .avatar-emoji {
            font-size: 40px;
        }

        /* ìƒíƒœ ì¸ë””ì¼€ì´í„° */
        .status-dot {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background: #2ed573;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(46, 213, 115, 0.4);
        }

        .status-dot.thinking {
            background: #ffa502;
            animation: blink 1s infinite;
        }

        .status-dot.speaking {
            background: #667eea;
            animation: pulse 0.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* í‘œì •ë³„ ì´ëª¨ì§€ */
        .avatar.happy .avatar-emoji::before { content: 'ğŸ˜Š'; }
        .avatar.sad .avatar-emoji::before { content: 'ğŸ˜¢'; }
        .avatar.surprised .avatar-emoji::before { content: 'ğŸ˜²'; }
        .avatar.thinking .avatar-emoji::before { content: 'ğŸ¤”'; }
        .avatar.angry .avatar-emoji::before { content: 'ğŸ˜ '; }

        /* ë‹«ê¸° ë²„íŠ¼ */
        .close-btn {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 24px;
            height: 24px;
            background: #ff4757;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(255, 71, 87, 0.4);
        }

        .avatar-wrapper:hover .close-btn {
            display: flex;
        }

        .close-btn:hover {
            transform: scale(1.1);
        }

        /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
        .loading-dots {
            display: inline-flex;
            gap: 4px;
        }

        .loading-dots span {
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            animation: loading 1.4s infinite;
        }

        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes loading {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* ì•„ë°”íƒ€ ì´ë¯¸ì§€ê°€ ìˆì„ ë•Œ */
        .avatar.has-image {
            background: white;
        }

        .avatar.has-image img {
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="floating-avatar" id="floatingAvatar">
        <!-- ë§í’ì„  -->
        <div class="speech-bubble" id="speechBubble">
            <div class="message-text" id="messageText">ì•ˆë…•í•˜ì„¸ìš”! ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”? ğŸ˜Š</div>
            <div class="message-time" id="messageTime"></div>
        </div>

        <!-- ì…ë ¥ ì˜ì—­ -->
        <div class="input-area" id="inputArea">
            <input type="text" id="chatInput" placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." />
            <button class="mic-btn" id="micBtn" title="ìŒì„± ì…ë ¥">ğŸ¤</button>
            <button class="send-btn" id="sendBtn" title="ì „ì†¡">â¤</button>
        </div>

        <!-- ì•„ë°”íƒ€ -->
        <div class="avatar-wrapper" id="avatarWrapper">
            <button class="close-btn" id="closeBtn" title="ë‹«ê¸°">âœ•</button>
            <div class="avatar" id="avatar">
                <!-- ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ í‘œì‹œ, ì—†ìœ¼ë©´ ì´ëª¨ì§€ -->
                <img src="images/face/ass_plain.png" alt="Alpha" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                <span class="avatar-emoji" style="display: none;">ğŸ¤–</span>
            </div>
            <div class="status-dot" id="statusDot"></div>
        </div>
    </div>

    <script>
        // ìƒíƒœ ê´€ë¦¬
        const state = {
            isExpanded: false,
            isRecording: false,
            isDragging: false,
            currentEmotion: 'normal',
            mediaRecorder: null,
            audioChunks: []
        };

        // DOM ìš”ì†Œ
        const elements = {
            floatingAvatar: document.getElementById('floatingAvatar'),
            speechBubble: document.getElementById('speechBubble'),
            inputArea: document.getElementById('inputArea'),
            avatar: document.getElementById('avatar'),
            avatarWrapper: document.getElementById('avatarWrapper'),
            chatInput: document.getElementById('chatInput'),
            sendBtn: document.getElementById('sendBtn'),
            micBtn: document.getElementById('micBtn'),
            closeBtn: document.getElementById('closeBtn'),
            messageText: document.getElementById('messageText'),
            messageTime: document.getElementById('messageTime'),
            statusDot: document.getElementById('statusDot')
        };

        // ì‹œê°„ í¬ë§·
        function formatTime() {
            const now = new Date();
            return now.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
        }

        // ì•„ë°”íƒ€ í´ë¦­ - í™•ì¥/ì¶•ì†Œ
        elements.avatar.addEventListener('click', (e) => {
            if (state.isDragging) return;
            e.stopPropagation();
            toggleExpand();
        });

        function toggleExpand() {
            state.isExpanded = !state.isExpanded;
            
            if (state.isExpanded) {
                elements.speechBubble.classList.add('show');
                elements.inputArea.classList.add('show');
                elements.chatInput.focus();
            } else {
                elements.speechBubble.classList.remove('show');
                elements.inputArea.classList.remove('show');
            }
        }

        // ë‹«ê¸° ë²„íŠ¼
        elements.closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (window.overlay?.close) {
                window.overlay.close();
            } else {
                window.close();
            }
        });

        // ë©”ì‹œì§€ ì „ì†¡
        elements.sendBtn.addEventListener('click', sendMessage);
        elements.chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        async function sendMessage() {
            const message = elements.chatInput.value.trim();
            if (!message) return;

            elements.chatInput.value = '';
            showLoading();

            try {
                const response = await fetch('http://localhost:3030/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });

                const data = await response.json();
                showMessage(data.reply, data.emotion);
            } catch (error) {
                showMessage('ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš” ğŸ˜…', 'sad');
            }
        }

        // ë¡œë”© í‘œì‹œ
        function showLoading() {
            elements.messageText.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
            elements.statusDot.classList.add('thinking');
            elements.speechBubble.classList.add('show');
        }

        // ========== ElevenLabs TTS ==========
        let currentAudio = null;
        
        async function speakText(text, emotion = 'normal') {
            // ì´ì „ ì˜¤ë””ì˜¤ ì¤‘ì§€
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            try {
                elements.statusDot.classList.add('speaking');
                console.log('ElevenLabs TTS ìš”ì²­:', text.substring(0, 50));
                
                const response = await fetch('http://localhost:3030/text-to-speech', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text,
                        model: 'eleven_multilingual_v2'
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`TTS ì˜¤ë¥˜: ${response.status}`);
                }
                
                const audioBlob = await response.blob();
                console.log('TTS ì‘ë‹µ ë°›ìŒ, í¬ê¸°:', audioBlob.size);
                
                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudio = new Audio(audioUrl);
                
                currentAudio.onended = () => {
                    elements.statusDot.classList.remove('speaking');
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                };
                
                currentAudio.onerror = (e) => {
                    console.error('ì˜¤ë””ì˜¤ ì¬ìƒ ì˜¤ë¥˜:', e);
                    elements.statusDot.classList.remove('speaking');
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                };
                
                await currentAudio.play();
                console.log('TTS ì¬ìƒ ì‹œì‘');
                
            } catch (error) {
                console.error('TTS ì˜¤ë¥˜:', error);
                elements.statusDot.classList.remove('speaking');
            }
        }

        // ë©”ì‹œì§€ í‘œì‹œ
        function showMessage(text, emotion = 'normal') {
            elements.messageText.textContent = text;
            elements.messageTime.textContent = formatTime();
            elements.statusDot.classList.remove('thinking', 'speaking');
            
            // í‘œì • ë³€ê²½
            changeExpression(emotion);
            
            // TTS ì¬ìƒ
            speakText(text, emotion);
            
            // ìë™ ë‹«ê¸° (10ì´ˆ í›„)
            setTimeout(() => {
                if (state.isExpanded) {
                    // ì…ë ¥ ì¤‘ì´ ì•„ë‹ˆë©´ ë§í’ì„ ë§Œ ìˆ¨ê¸°ê¸°
                    if (!elements.chatInput.value) {
                        elements.speechBubble.classList.remove('show');
                    }
                }
            }, 10000);
        }

        // í‘œì • ë³€ê²½
        function changeExpression(emotion) {
            const imgMap = {
                'normal': 'ass_plain.png',
                'happy': 'ass_talking.png',
                'sad': 'ass_sad.png',
                'surprised': 'ass_surpirsed.png',
                'thinking': 'ass_tired.png',
                'angry': 'ass_angry.png'
            };

            const img = elements.avatar.querySelector('img');
            if (img && imgMap[emotion]) {
                img.src = `images/face/${imgMap[emotion]}`;
            }

            state.currentEmotion = emotion;
        }

        // ìŒì„± ë…¹ìŒ
        elements.micBtn.addEventListener('click', toggleRecording);

        async function toggleRecording() {
            if (state.isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];

                state.mediaRecorder.ondataavailable = (e) => {
                    state.audioChunks.push(e.data);
                };

                state.mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(state.audioChunks, { type: 'audio/webm' });
                    await sendVoiceMessage(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };

                state.mediaRecorder.start();
                state.isRecording = true;
                elements.micBtn.classList.add('recording');
                elements.micBtn.textContent = 'â¹';
                elements.statusDot.classList.add('speaking');

            } catch (error) {
                console.error('ë§ˆì´í¬ ì ‘ê·¼ ì˜¤ë¥˜:', error);
                showMessage('ë§ˆì´í¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ìš” ğŸ˜…', 'sad');
            }
        }

        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop();
                state.isRecording = false;
                elements.micBtn.classList.remove('recording');
                elements.micBtn.textContent = 'ğŸ¤';
                showLoading();
            }
        }

        async function sendVoiceMessage(audioBlob) {
            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');

                const response = await fetch('http://localhost:3030/chat/voice', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                showMessage(data.reply, data.emotion);

            } catch (error) {
                console.error('ìŒì„± ì „ì†¡ ì˜¤ë¥˜:', error);
                showMessage('ìŒì„± ì¸ì‹ì— ì‹¤íŒ¨í–ˆì–´ìš” ğŸ˜…', 'sad');
            }
        }

        // ë“œë˜ê·¸ ê¸°ëŠ¥
        let dragOffset = { x: 0, y: 0 };

        elements.avatarWrapper.addEventListener('mousedown', (e) => {
            if (e.target === elements.closeBtn) return;
            
            state.isDragging = false;
            dragOffset = {
                x: e.clientX,
                y: e.clientY
            };

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', onDragEnd);
        });

        function onDrag(e) {
            const dx = e.clientX - dragOffset.x;
            const dy = e.clientY - dragOffset.y;

            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                state.isDragging = true;
            }

            if (state.isDragging && window.overlay?.moveBy) {
                window.overlay.moveBy(dx, dy);
                dragOffset = { x: e.clientX, y: e.clientY };
            }
        }

        function onDragEnd() {
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', onDragEnd);
            
            setTimeout(() => {
                state.isDragging = false;
            }, 100);
        }

        // ì™¸ë¶€ í´ë¦­ ì‹œ ì¶•ì†Œ
        document.addEventListener('click', (e) => {
            if (!elements.floatingAvatar.contains(e.target) && state.isExpanded) {
                toggleExpand();
            }
        });

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ Alpha í”Œë¡œíŒ… ì•„ë°”íƒ€ ì‹œì‘!');
            elements.messageTime.textContent = formatTime();
            
            // ì ì‹œ í›„ í™˜ì˜ ë©”ì‹œì§€ í‘œì‹œ
            setTimeout(() => {
                elements.speechBubble.classList.add('show');
                setTimeout(() => {
                    elements.speechBubble.classList.remove('show');
                }, 5000);
            }, 1000);
        });

        // ì™¸ë¶€ì—ì„œ ì œì–´í•  ìˆ˜ ìˆëŠ” API
        window.alphaAvatar = {
            show: () => { state.isExpanded = false; toggleExpand(); },
            hide: () => { state.isExpanded = true; toggleExpand(); },
            speak: (text, emotion) => showMessage(text, emotion),
            setExpression: (emotion) => changeExpression(emotion)
        };
    </script>
</body>
</html>
